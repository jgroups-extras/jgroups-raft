package org.jgroups.raft;

import org.jgroups.JChannel;
import org.jgroups.protocols.raft.RAFT;
import org.jgroups.raft.command.JGroupsRaftReadCommandOptions;
import org.jgroups.raft.command.JGroupsRaftWriteCommandOptions;
import org.jgroups.raft.configuration.RaftProtocolBuilder;
import org.jgroups.raft.configuration.RuntimeProperties;
import org.jgroups.raft.exceptions.JRaftException;
import org.jgroups.raft.internal.JGroupsRaftFactory;
import org.jgroups.raft.internal.command.JRaftCommand;
import org.jgroups.raft.internal.registry.SerializationRegistry;
import org.jgroups.raft.logger.JRaftEventLogger;

import java.io.InputStream;
import java.util.Objects;
import java.util.Properties;
import java.util.function.Consumer;
import java.util.function.Function;

import net.jcip.annotations.ThreadSafe;
import org.infinispan.protostream.SerializationContextInitializer;

/**
 * Entry point for the JGroups Raft API.
 *
 * <p>
 * The {@link JGroupsRaft} interface serves as the main entry point for interacting with the JGroups Raft. It provides
 * methods to build, run, and manage replicated state machines based on the Raft consensus algorithm. This interface
 * includes methods to start and stop the instance, submit commands to the replicated state machine, perform administrative
 * tasks, and access the current state of the underlying Raft<sup>1</sup> algorithm. Additionally, the {@link JGroupsRaft}
 * instance is thread-safe.
 * </p>
 *
 * <h2>Instantiation</h2>
 *
 * <p>
 * To create a new instance of {@link JGroupsRaft}, use the {@link #builder(Object, Class)} method. This method returns a {@link Builder}
 * instance, which can be used to configure and build the instance. The builder requires a state machine and configuration
 * settings to construct a {@link JChannel} instance.
 * </p>
 *
 * <p>
 * The builder also allows registering custom serialization context initializers and marshaller to serialize data. Additionally,
 * it provides access to a {@link RaftProtocolBuilder} to configure the underlying {@link RAFT} protocol.
 * </p>
 *
 * <h2>Lifecycle</h2>
 *
 * <p>
 * The lifecycle of the {@link JGroupsRaft} instance is managed through the {@link #start()} and {@link #stop()} methods.
 * The {@link #start()} method initializes the instance, connects to the underlying JGroups channel, and starts the Raft algorithm.
 * Conversely, the {@link #stop()} method halts the Raft algorithm, disconnects from the JGroups channel, and cleans up any resources
 * utilized by the instance. It's important to note that a single instance can only be started once and cannot be restarted
 * after it has been stopped.
 * </p>
 *
 * <h3>Usage Steps</h3>
 *
 * <b>Start</b>
 * <p>
 * After creating an instance using the {@link Builder}, before submitting any operations, the instance must be started by
 * invoking the {@link #start()} method. This will initialize internal components and connect to the cluster as defined in the configuration.
 * Once started, users can submit operations to the state machine for replication and processing.
 * </p>
 *
 * <p>
 * The initialization phase includes the generation of a schema based on the state machine's methods. This schema is used to
 * validate compatibility between versions of the application. The schema is loaded from the local node log and verified
 * against the current version provided to the instance. If the schema is not compatible, an exception will be thrown.
 * </p>
 *
 * <p>
 * The start method is also responsible for connecting to the underlying JGroups channel. This step will create the cluster
 * and initialize the {@link RAFT} protocol. The state machine is restored from the log during this phase.
 * </p>
 *
 * <b>Stop</b>
 * <p>
 * When the instance is no longer needed, it should be stopped by calling the {@link #stop()} method. This will disconnect
 * from the cluster and clean up all resources. The schema generated by the state machine will be flushed to the local log,
 * making the instance unusable afterward. Any subsequent attempts to start the instance or submit operations will result in failure.
 * </p>
 *
 * <p>
 * If a {@link JChannel} is provided during configuration, and it is already connected, the instance will not manage its
 * lifecycle. Invoking {@link #start()} or {@link #stop()} methods will have no effect on the channel. However, these methods are still
 * required to initialize internal components properly. In such cases, it is the application's responsibility to handle the channel's lifecycle,
 * including stopping it when necessary.
 * </p>
 *
 * <h2>Command Submission</h2>
 *
 * <p>
 * After initialization, we can submit operations with the {@link #write(Function)} and {@link #read(Function)} methods
 * and its variants. These method provides a functional interface to execute the command using the state machine as argument.
 * The {@link #write(Function)} method is used for commands that modify the state machine, while the {@link #read(Function)}
 * method is used for commands that only read the state machine's state.
 * </p>
 *
 * <h2>Administration</h2>
 *
 * <p>
 * The {@link #administration()} method provides access to the administrative interface. This interface is aimed at operators
 * to perform administrative tasks to manage the cluster. See {@link JGroupsRaftAdministration} for more information.
 * </p>
 *
 * <h2>State</h2>
 *
 * <p>
 * The {@link #state()} method provides access to the current state of the {@link RAFT} protocol. This information is useful for
 * monitoring the state of the Raft algorithm<sup>1</sup> and understanding the current status of the cluster. See
 * {@link JGroupsRaftState} for more information.
 * </p>
 *
 * @param <T> the type of the state machine.
 * @since 2.0
 * @author Jos√© Bolina
 * @see <a href="https://raft.github.io/"><sup>1</sup>Raft</a>
 * @see JRaftCommand
 * @see StateMachine
 */
@ThreadSafe
public interface JGroupsRaft<T> {

    final class Builder<T> implements org.jgroups.raft.util.pattern.Builder<JGroupsRaft<T>> {
        private final T stateMachine;
        private final Class<T> api;
        private final SerializationRegistry registry;
        private final RaftProtocolBuilder<T> raftBuilder;

        private InputStream jgroupsConfig;
        private String clusterName;
        private JChannel channel;
        private RuntimeProperties runtimeProperties;
        private JRaftEventLogger eventLogger;

        private Builder(T stateMachine, Class<T> api) {
            this.stateMachine = Objects.requireNonNull(stateMachine, "state machine cannot be null");
            this.api = Objects.requireNonNull(api, "api class cannot be null");
            this.registry = SerializationRegistry.create();
            this.raftBuilder = new RaftProtocolBuilder<>(this);
        }

        /**
         * Defines the name of the cluster to create with JGroups.
         *
         * <p>
         * The cluster name is utilized when connecting the JGroups channel. All nodes must share the same name to create
         * a cluster.
         * </p>
         *
         * @param clusterName name of the cluster to create with JGroups.
         * @return the builder instance.
         */
        public Builder<T> withClusterName(String clusterName) {
            this.clusterName = clusterName;
            return this;
        }

        /**
         * Defines the JGroups configuration file to be used.
         *
         * <p>
         * The JGroups configuration file is utilized to create the JGroups channel.
         * </p>
         *
         * @param jgroupsConfig file with the JGroups configuration.
         * @return the builder instance.
         */
        public Builder<T> withJGroupsConfig(InputStream jgroupsConfig) {
            this.jgroupsConfig = jgroupsConfig;
            return this;
        }

        /**
         * Defines the path to the JGroups configuration file.
         *
         * <p>
         * The JGroups configuration file is utilized to create the JGroups channel. The file must be in the classpath.
         * </p>
         *
         * @param jgroupsConfig path to the JGroups configuration file.
         * @return the builder instance.
         */
        public Builder<T> withJGroupsConfig(String jgroupsConfig) {
            Objects.requireNonNull(jgroupsConfig, "jgroupsConfig cannot be null");
            return withJGroupsConfig(getClass().getClassLoader().getResourceAsStream(jgroupsConfig));
        }

        /**
         * Defines configuration properties to be used.
         *
         * @param runtimeProperties configuration properties to be used.
         * @return the builder instance.
         */
        public Builder<T> withRuntimeProperties(RuntimeProperties runtimeProperties) {
            this.runtimeProperties = runtimeProperties;
            return this;
        }

        /**
         * Defines configuration properties to be used.
         *
         * @param properties configuration properties to be used.
         * @return the builder instance.
         */
        public Builder<T> withRuntimeProperties(Properties properties) {
            return withRuntimeProperties(RuntimeProperties.from(properties));
        }

        /**
         * Defines the JGroups channel to be used.
         *
         * <p>
         * The JGroups channel must contain a valid stack. The stack requires {@link org.jgroups.protocols.raft.RAFT}
         * and an election algorithm.
         * </p>
         *
         * <p>
         * If the channel is disconnected, the instance will manage the channel's lifecycle to start and shutdown. Otherwise,
         * the channel must be sopped by the application.
         * </p>
         *
         * @param channel the JGroups channel to be used.
         * @return the builder instance.
         */
        public Builder<T> withChannel(JChannel channel) {
            this.channel = channel;
            return this;
        }

        /**
         * Register a new serialization context initializer to serialize commands.
         *
         * <p>
         * The context is registered and is utilized for command and data serialization.
         * </p>
         *
         * @param sci the serialization context initializer to be registered.
         * @return the builder instance.
         */
        public Builder<T> registerSerializationContextInitializer(SerializationContextInitializer sci) {
            registry.register(sci);
            return this;
        }

        /**
         * Register a new marshaler to serialize commands.
         *
         * @param marshaller the marshaler to be registered.
         * @return the builder instance.
         */
        public Builder<T> registerMarshaller(JGroupsRaftCustomMarshaller<?> marshaller) {
            registry.register(marshaller);
            return this;
        }

        /**
         * Defines the event logger to publish internal events.
         *
         * <p>
         * The default event logger is disabled.
         * </p>
         *
         * @param eventLogger the event logger to be used.
         * @return the builder instance.
         */
        public Builder<T> withEventLogger(JRaftEventLogger eventLogger) {
            this.eventLogger = eventLogger;
            return this;
        }

        /**
         * Configures the underlying {@link RAFT} protocol.
         *
         * <p>
         * This configuration will take precedence over the configurations defined in the configuration file.
         * </p>
         *
         * @return A builder to configure the {@link RAFT} protocol.
         */
        public RaftProtocolBuilder<T> configureRaft() {
            return raftBuilder;
        }

        public void validate() {
            if (jgroupsConfig == null && channel == null)
                throw new IllegalStateException("Either jgroupsConfig or channel must be provided");

            // Verify only one of jgroupsConfig or channel is provided.
            if (jgroupsConfig != null && channel != null)
                throw new IllegalStateException("Only one of jgroupsConfig or channel must be provided");

            // If jgroupsConfig is provided, clusterName must be provided.
            if (jgroupsConfig != null && clusterName == null)
                throw new IllegalStateException("clusterName must be provided when jgroupsConfig is provided");

            if (channel != null && !channel.isConnected() && clusterName == null)
                throw new IllegalStateException("clusterName should be defined for a disconnected channel to connect to");
        }

        /**
         * Validates the builder and creates a new {@link JGroupsRaft} instance.
         *
         * <p>
         * The builder has specific requirements:
         *
         * <ul>
         *     <li>Either a JGroups channel or the configuration must be provided;</li>
         *     <li>If a configuration is provided, the cluster name must be defined;</li>
         *     <li>If a disconnected channel is provided, the cluster name must be defined;</li>
         * </ul>
         * </p>
         *
         * @return A new instance.
         * @throws IllegalStateException if the builder is not properly configured.
         * @throws JRaftException if an error occurs while creating the instance.
         */
        public JGroupsRaft<T> build() {
            validate();

            JRaftEventLogger el = eventLogger;
            if (el == null)
                el = JRaftEventLogger.disabled();

            if (runtimeProperties == null)
                runtimeProperties = RuntimeProperties.create().build();

            if (jgroupsConfig != null) {
                try {
                    JChannel ch = new JChannel(jgroupsConfig);
                    RAFT r = RAFT.findProtocol(RAFT.class, ch.getProtocolStack().getTopProtocol(), true);
                    if (r != null) raftBuilder.build(r);
                    return JGroupsRaftFactory.create(clusterName, ch, stateMachine, api, registry, el, runtimeProperties);
                } catch (Exception e) {
                    throw new JRaftException(e);
                }
            }

            if (clusterName == null && channel.isConnected())
                clusterName = channel.getClusterName();

            return JGroupsRaftFactory.create(clusterName, channel, stateMachine, api, registry, el, runtimeProperties);
        }
    }

    /**
     * Creates a new builder to configure the {@link JGroupsRaft} instance.
     *
     * @param stateMachine the concrete local implementation of the state machine. The state machine should not be null.
     * @param api the class defining the state machine API. The class should not be null.
     * @return a new builder to configure the {@link JGroupsRaft} instance.
     * @param <T> the type of the state machine
     * @throws NullPointerException if any of the arguments is null.
     */
    static <T> Builder<T> builder(T stateMachine, Class<T> api) {
        Objects.requireNonNull(stateMachine, "state machine cannot be null");
        Objects.requireNonNull(api, "api class cannot be null");
        return new Builder<>(stateMachine, api);
    }

    /**
     * Starts the instance.
     *
     * <p>
     * This method initializes the instance, connects to the underlying JGroups channel, and starts the Raft algorithm.
     * This method <b>must</b> be invoked before submitting any commands. An instance can not be utilized after it is {@link #stop()}.
     * </p>
     *
     * @throws IllegalStateException in case of misconfiguration of the JGroups channel or trying to restart the instance.
     */
    void start();

    /**
     * Stops the instance.
     *
     * <p>
     * The node will disconnect from the cluster and stop the Raft algorithm. A schema generated from the state machine
     * is flushed to the log for backwards compatibility validation. After the instance is stopped, it can not be
     * utilized or restarted.
     * </p>
     */
    void stop();

    /**
     * The current role of the node in the Raft algorithm.
     *
     * @return the current role of the node in the Raft algorithm.
     */
    JGroupsRaftRole role();

    /**
     * Submits a write command to the state machine.
     *
     * <p>
     * The function accepts a state machine as argument. The function should utilize the state machine to invoke the
     * methods annotated with {@link StateMachineWrite}. When the method is invoked, it will replicate the command across
     * the cluster and wait for the command to be committed. Once the command is committed, the function will return.
     * </p>
     *
     * <b>Only the methods are invoked in Raft. The lambda is executed locally and is not atomic.</b>
     *
     * @param function the function to execute using the state machine as argument.
     * @return the result of the function.
     * @param <O> the type of the result.
     */
    default <O> O write(Function<T, O> function) {
        return write(function, null);
    }

    /**
     * Creates a write-only view of the underlying state machine.
     *
     * <p>
     * The returned instance only allows invoking methods annotated with {@link StateMachineWrite}. Invoking read commands
     * will throw an exception.
     * </p>
     *
     * @param options Options utilized for all submitted commands.
     * @return a write-only view of the underlying state machine.
     */
    T writeOnly(JGroupsRaftWriteCommandOptions options);

    /**
     * Creates a read-only view of the underlying state machine.
     *
     * <p>
     * The returned instance only allows invoking methods annotated with {@link StateMachineRead}. Invoking write commands
     * will throw an exception.
     * </p>
     *
     * @param options Options utilized for all submitted commands.
     * @return a read-only view of the underlying state machine.
     */
    T readOnly(JGroupsRaftReadCommandOptions options);

    /**
     * Submits a write command to the state machine.
     *
     * <p>
     * This method is similar to {@link #write(Function)}, but it accepts options to change the command behavior during
     * execution.
     * </p>
     *
     * <b>Only the methods are invoked in Raft. The lambda is executed locally and is not atomic.</b>
     *
     * @param function the function to execute using the state machine as argument.
     * @param options options to change the command behavior during execution.
     * @return the result of the function.
     * @param <O> the type of the result.
     * @see #write(Function)
     */
    <O> O write(Function<T, O> function, JGroupsRaftWriteCommandOptions options);

    /**
     * Submits a write command to the state machine.
     *
     * <p>
     * This method is similar to {@link #write(Function)}, but it accepts a consumer instead of a function.
     * </p>
     *
     * <b>Only the methods are invoked in Raft. The lambda is executed locally and is not atomic.</b>
     *
     * @param consumer the consumer to execute using the state machine as argument.
     * @see #write(Function)
     */
    default void write(Consumer<T> consumer) {
        write(consumer, null);
    }

    /**
     * Submits a write command to the state machine.
     *
     * <p>
     * This method is similar to {@link #write(Function, JGroupsRaftWriteCommandOptions)}, but it accepts a consumer instead of a function.
     * </p>
     *
     * <b>Only the methods are invoked in Raft. The lambda is executed locally and is not atomic.</b>
     *
     * @param consumer the consumer to execute using the state machine as argument.
     * @param options options to change the command behavior during execution.
     * @see #write(Function, JGroupsRaftWriteCommandOptions)
     */
    default void write(Consumer<T> consumer, JGroupsRaftWriteCommandOptions options) {
        write(sm -> {
            consumer.accept(sm);
            return null;
        });
    }

    /**
     * Submits a read command to the state machine.
     *
     * <p>
     * The function accepts a state machine as argument. The function should utilize the state machine to invoke the
     * methods annotated with {@link StateMachineRead}. When the method is invoked, it will submit the command through
     * the Raft algorithm. Depending on the configuration, the command may be served locally or by the leader. Once the
     * command is executed, the function will return.
     * </p>
     *
     * <b>Only the methods are invoked in Raft. The lambda is executed locally and is not atomic.</b>
     *
     * @param function the function to execute using the state machine as argument.
     * @return the result of the function.
     * @param <O> the type of the result.
     */
    default <O> O read(Function<T, O> function) {
        return read(function, null);
    }

    /**
     * Submits a read command to the state machine.
     *
     * <p>
     * This method is similar to {@link #read(Function)}, but it accepts a consumer instead of a function.
     * </p>
     *
     * <b>Only the methods are invoked in Raft. The lambda is executed locally and is not atomic.</b>
     *
     * @param consumer the consumer to execute using the state machine as argument.
     * @see #read(Function)
     */
    default void read(Consumer<T> consumer) {
        read(sm -> {
            consumer.accept(sm);
            return null;
        });
    }

    /**
     * Submits a read command to the state machine.
     *
     * <p>
     * This method is similar to {@link #read(Function)}, but it accepts options to change the command behavior during
     * execution.
     * </p>
     *
     * <b>Only the methods are invoked in Raft. The lambda is executed locally and is not atomic.</b>
     *
     * @param function the function to execute using the state machine as argument.
     * @param options options to change the command behavior during execution.
     * @return the result of the function.
     * @param <O> the type of the result.
     */
    <O> O read(Function<T, O> function, JGroupsRaftReadCommandOptions options);

    /**
     * Administrative interface to manage the cluster.
     *
     * <p>
     * This API provides methods for administrative tasks, aimed for operator or scripting.
     * </p>
     *
     * @return an API to manage the cluster.
     */
    JGroupsRaftAdministration administration();

    /**
     * Internal state of the Raft algorithm.
     *
     * <p>
     * This API provides a read-only view of the internals of the Raft algorithm. This is information is useful to
     * analyze how the cluster is behaving.
     * </p>
     *
     * @return Raft's internal state.
     */
    JGroupsRaftState state();
}
